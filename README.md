# **medods_hire_me**
Сервис аутентификации пользователей. 

## **Содержание**

**1.** [Принцип работы](#принцип-работы)

**2.** [Endpoints](#endpoints)

**3.** [Запуск приложения](#запуск-приложения)

## **Принцип работы**
*Access* токен тип *JWT*, алгоритм **SHA512**, хранит в себе следующие данные:
- *IP* пользователя
- *GUID* идентификатор пользователя
- *JTI* идентификатор пары токенов
- *expires_at* время до которого будет валиден

Refresh токен является случайным набором байт.

В базе данных хранится две таблицы:
```sql
CREATE TABLE IF NOT EXISTS users(
    userID UUID primary key, -- GUID 
    email text -- email пользователя
);

CREATE TABLE IF not EXISTS tokens(
    jti UUID primary key, -- Идентификатор пары токенов
    userID UUID not null, -- GUID
    ip text not null, -- IP пользователя, которому была выдана пара токенов
    token_hash TEXT unique, -- Hash refresh токена, создан с помощью bcrypt
    expires_at TIMESTAMP not null, -- Временная метка, до которой refresh токен будет валиден

    FOREIGN KEY (userID) REFERENCES users(userID)
        ON DELETE CASCADE
);
```
После refresh операции данные о предыдущей паре токенов удаляются, что гарантирует защиту от повторного использования.
Также реализована логика черного списка для access токена in-Memory cache. Мы храним пары *JTI* и *IP* всех валидных идентификаторов на данный момент. 

В случае если мы сделали операцию _refresh_ для пары токенов, но время валидности access токена еще не вышло, пользователь не сможет с помощью старого токена обращаться к защищенному *API*. Также этот механизм позволяет легко определять использование access токена с другого *IP* и блокировать подозрительную операцию, не нагружая базу данных.

> *Refresh* операцию для *Access* токена можно выполнить только тем *Refresh* токеном который был выдан вместе с ним

Если я правильно понял данное требование, при _refresh_ операции мы обязаны предоставлять пару токенов, а не только *refresh* токен, и такую логику я реализовал.  В случае, если выданная пара токенов обладает разными *JWI* идентификаторами, сервер заблокирует такую операцию.


## **Endpoints**
### **POST auth/token**
Выдает токен аутентификации, принимает GUID идентификатор пользователя и выдает пару ключей. Количество выданых токенов на 1 пользователя не ограничено.
- _Request Body_  
```json
{
    "user_id": "{GUID}"
}
```
- _Response Body_
```json
{
    "access_token": "{AccessToken}",
    "refresh_token": "{RefreshToken}"
}
```

### **POST atho/refresh**
Перевыпускает токен аутентификации.
На вход принимает пару токенов и перевыпускает их. Старые токены после refresh операции станут не валидными.

В случае если IP адрес отправителя не совпадет с IP адресом в токене, на почту владельца токена придет уведомление, а refresh операция завершится ошибкой
- _Request Body_  
```json
{
    "access_token": "{AccessToken}",
    "refresh_token": "{RefreshToken}"
}
```
- _Response Body_
```json
{
    "access_token": "{AccessToken}",
    "refresh_token": "{RefreshToken}"
}
```


### **PATCH protected/mail**
Защищенный API для изменения адреса Email пользователя, на который будет приходить оповещение о подозрительной активности.

Если у пользователя уже был указал email, адрес изменится, и на старый адрес придет уведомление об этом.    
- _Required Headers_
```http
Authorization: Bearer {AccessToken}
```

- _Request Body_ 
```json
{
    "email": "maxro2705@gmail.com"
}
```
- _Response Body_
```json
{
    "status": "Ok"
}
```

## **Запуск приложения**
### **Генерация .env файла**
```bash
sh scripts/genetate-env.sh
```

### **Запуск**
Сервер будет запущен нa 8080 порту
```bash
docker compose up -d --build
```

### **Подключение к базе данных**
```bash
docker exec -it postgres_db psql -U postgres
```
